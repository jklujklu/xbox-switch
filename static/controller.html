<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        html,
        body {
            position: relative;
            width: 100%;
            height: 100%;
        }

        body {
            color: #333;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
        }

        a {
            color: #0064c8;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        a:visited {
            color: #0050a0;
        }

        .controller.svelte-1xis06h.svelte-1xis06h {
            position: relative;
            width: 100%;
        }

        .controller.svelte-1xis06h > .svelte-1xis06h {
            position: absolute;
            display: block;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            padding: 0;
            z-index: 1;
        }

        .controller.svelte-1xis06h > .svelte-1xis06h:not(.pad):not(.stick):not(.well) {
            -webkit-animation: svelte-1xis06h-flash 4s ease 1 2s;
            animation: svelte-1xis06h-flash 4s ease 1 2s;
        }

        .pad.svelte-1xis06h.svelte-1xis06h {
            background-image: url("https://s3-us-west-2.amazonaws.com/s.cdpn.io/13471/xbox-controller.jpg");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: relative;
            width: 100%;
            height: 0;
            padding-top: 56.2416%;
        }

        .well.svelte-1xis06h.svelte-1xis06h {
            background: #16bef2;
            background-image: linear-gradient(25deg, #44494a, #555658 40%, #555658 60%, #44494a);
            left: 26.5%;
            top: 14.6%;
            width: 10.6%;
            padding-top: 10.2%;
            border-radius: 100%;
            box-shadow: inset 0.05vw -0.05vw 0.1vw 0.05vw rgba(0, 0, 0, 0.3), inset -0.05vw 0.05vw 0.05vw 0.05vw rgba(255, 255, 255, 0.3);
        }

        .well.right.svelte-1xis06h.svelte-1xis06h {
            left: auto;
            right: 35.1%;
            top: 33.1%;
        }

        .well.svelte-1xis06h.svelte-1xis06h::before {
            content: "";
            position: absolute;
            left: 7%;
            top: 8%;
            width: 86%;
            height: 84%;
            border-radius: 100%;
            background-color: #16bef2;
            box-shadow: inset -0.05vw 0.1vw 0.2vw 0.2vw #444547, inset 0vw -0.1vw 0.1vw 0.1vw #18607c, inset 0 0 0 0.2vw #444547, inset 0 0 0.2vw 0.5vw #18607c, inset 0 0 2vw 1vw #18607c;
            z-index: 0;
        }

        .stick.svelte-1xis06h.svelte-1xis06h {
            position: absolute;
            left: 11%;
            top: 2%;
            background: url("https://s3-us-west-2.amazonaws.com/s.cdpn.io/13471/xbox-controller.jpg");
            width: 78%;
            padding-top: 78%;
            background-position: 30.1% 18.5%;
            background-size: 1300%;
            border-radius: 100%;
            box-shadow: inset 0.5vw -0.5vw 1vw 0.1vw rgba(0, 0, 0, 0.3), -0.5vw 1vw 1vw rgba(0, 0, 0, 0.5), -1.2vw 2vw 2vw rgba(0, 0, 0, 0.6);
            transition: none;
            z-index: 3;
        }

        .stick.svelte-1xis06h.svelte-1xis06h:after {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: #aaa;
            border-radius: 100%;
            mix-blend-mode: overlay;
            box-shadow: inset 0 0 1vw 1vw rgba(255, 255, 255, 0), inset 0 0 0.3vw 0.5vw rgba(97, 229, 255, 0.5), 0 0 0.6vw 0.4vw #5ee0f8, 0 0 1.2vw 0.4vw rgba(94, 224, 248, 0.8);
            transition: all 0.1s ease;
            opacity: 0;
        }

        .button.on.svelte-1xis06h.svelte-1xis06h,
        .dpad.on.svelte-1xis06h.svelte-1xis06h,
        .bumper.on.svelte-1xis06h.svelte-1xis06h,
        .stick.click.svelte-1xis06h.svelte-1xis06h:after {
            opacity: 1;
        }

        .button.svelte-1xis06h.svelte-1xis06h {
            width: 4.7%;
            padding-top: 4.7%;
            border-radius: 100%;
            right: 29.3%;
            top: 28%;
            background: #5cff00;
            box-shadow: 0.1vw 0.2vw 0.4vw 0.3vw #5cff00, 0.1vw 0.3vw 2vw 0.5vw #5cff00;
            mix-blend-mode: overlay;
            transition: all 0.25s ease;
            z-index: 2;
            opacity: 0;
        }

        .button.b.svelte-1xis06h.svelte-1xis06h {
            right: 24.4%;
            top: 21%;
            background: #ff0033;
            box-shadow: 0vw 0vw 0.4vw 0.3vw #ff0033, 0.1vw 0.3vw 2vw 0.5vw #ff0033;
        }

        .button.x.svelte-1xis06h.svelte-1xis06h {
            right: 34.1%;
            top: 20%;
            background: #00ebff;
            box-shadow: 0.1vw 0.2vw 0.4vw 0.3vw #00ebff, 0.1vw 0.3vw 2vw 0.5vw #00ebff;
        }

        .button.y.svelte-1xis06h.svelte-1xis06h {
            right: 29.3%;
            top: 12%;
            background: #ffd600;
            box-shadow: 0vw 0.1vw 0.4vw 0.3vw #ffd600, 0.1vw 0.3vw 2vw 0.5vw #ffd600;
        }

        .button.map.svelte-1xis06h.svelte-1xis06h,
        .button.menu.svelte-1xis06h.svelte-1xis06h {
            left: 43.4%;
            top: 21.4%;
            width: 2.9%;
            padding-top: 2.8%;
            background: white;
            box-shadow: inset 0 0 0.5vw 0.2vw #5ee0f8, 0 0.1vw 0.3vw 0.4vw #5ee0f8, 0 0.1vw 1.5vw 0.7vw #5ee0f8, 0 0.1vw 0.2vw 0.1vw #5ee0f8;
        }

        .button.menu.svelte-1xis06h.svelte-1xis06h {
            left: 53.8%;
        }

        .button.xbox.svelte-1xis06h.svelte-1xis06h {
            left: 47.6%;
            top: 7.7%;
            width: 4.8%;
            padding-top: 4.4%;
            background: #5cff00;
            mix-blend-mode: screen;
            box-shadow: inset 0 0 0.1vw 0.1vw white, 0 0.1vw 0.2vw 0.2vw white, 0 0.1vw 0.5vw 0.1vw white, 0 0.1vw 2vw 0.5vw rgba(92, 255, 0, 0.7);
            transition-duration: 0.5s;
        }

        .dpad.svelte-1xis06h.svelte-1xis06h {
            width: 3.5%;
            padding-top: 4.8%;
            border-radius: 20%;
            left: 38.8%;
            top: 34.8%;
            background: linear-gradient(0deg, transparent, #4ed5e0, #33f0ff);
            box-shadow: 0 -1.4vw 1.7vw 0.2vw #4ed5e0, 0 -2vw 1.4vw 0.2vw rgba(255, 255, 255, 0.1);
            mix-blend-mode: overlay;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .dpad.dr.svelte-1xis06h.svelte-1xis06h {
            left: 42%;
            top: 40%;
            transform: rotate(90deg);
        }

        .dpad.dd.svelte-1xis06h.svelte-1xis06h {
            top: 46%;
            transform: rotate(180deg);
        }

        .dpad.dl.svelte-1xis06h.svelte-1xis06h {
            left: 35.6%;
            top: 40%;
            transform: rotate(270deg);
        }

        .bumper.svelte-1xis06h.svelte-1xis06h {
            left: 25.5%;
            top: 3.6%;
            width: 13%;
            padding-top: 4%;
            transform: rotate(-20deg);
            border-radius: 100%;
            background: #7edbff;
            box-shadow: 0vw 0vw 2vw 1vw #7edbff;
            mix-blend-mode: darken;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .bumper.svelte-1xis06h.svelte-1xis06h:after {
            content: "";
            left: 20%;
            top: 10%;
            width: 60%;
            height: 40%;
            border-radius: 100%;
            background: cyan;
            mix-blend-mode: screen;
            box-shadow: 0vw 0vw 1vw 0.5vw cyan;
            z-index: 2;
        }

        .bumper.right.svelte-1xis06h.svelte-1xis06h {
            left: auto;
            right: 25.4%;
            transform: scaleX(-1) rotate(-22deg);
        }

        .trigger.svelte-1xis06h.svelte-1xis06h {
            left: 15.1%;
            top: 24%;
            width: 10%;
            padding-top: 6px;
            transform: scaleX(1) scaleY(1) rotate(-69deg);
            border-radius: 2vw;
            background: #7edbff;
            box-shadow: 0vw -1vw 4vw 4vw #7edbff;
            mix-blend-mode: darken;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .trigger.right.svelte-1xis06h.svelte-1xis06h {
            left: auto;
            right: 15.1%;
            transform: scaleX(-1) scaleY(1) rotate(-69deg);
        }

        @-webkit-keyframes svelte-1xis06h-flash {
            0% {
                opacity: 0;
            }
            25% {
                opacity: 1;
            }
        }

        @keyframes svelte-1xis06h-flash {
            0% {
                opacity: 0;
            }
            25% {
                opacity: 1;
            }
        }

        body,
        html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #pad {
            max-height: 100%;
            width: 100%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        h1 {
            margin: 2vw 0 10px;
            font-size: 2.6vw;
        }

        p {
            margin: 10px;
        }

        h2 {
            margin: 1vw;
            font-size: 2vw;
        }

        a {
            color: #17a1cc;
        }

        body {
            flex-direction: row;
        }

        #left {
            margin-top: 15vh;
            display: flex;
            align-items: center;
            flex-direction: column;
            height: 80vh;
        }

        #right {
            display: flex;
            align-items: center;
            flex-direction: column;
        }

        #list {
            width: 25vw;
            height: 80vh;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            overflow-y: scroll;
        }

        #split {
            width: 0.15vw;
            height: 100%;
            background: #e7e7e7;
        }

        .amiibo {
            width: 30%;
            margin-top: 10px;
        }

        .amiibo img {
            width: 100%;
            cursor: pointer;
        }

        #list::-webkit-scrollbar { /*滚动条整体样式*/
            width: 5px; /*高宽分别对应横竖滚动条的尺寸*/
            height: 1px;
        }

        #list::-webkit-scrollbar-thumb { /*滚动条里面小方块*/
            border-radius: 5px;
            -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            background: #535353;
        }

        #list::-webkit-scrollbar-track { /*滚动条里面轨道*/
            -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            background: #EDEDED;
        }
    </style>
</head>
<body>
<div id="left">
    <h1>Xbox Controller</h1>
    <p>Plug in your XBOX controller via USB and refresh the page to activate the controller</p>
    <div id="pad"></div>
</div>
<div id="split"></div>
<div id="right" style="margin-top: 15vh;">
    <h1>Zelda AMIIBO List</h1>
    <p>Amiibo for Zelda. Click to load, click again to remove</p>
    <div id="list">
        <div class="amiibo">
            <img src="image/01.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/02.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/03.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/04.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/05.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/06.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/07.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/08.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/09.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/10.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/11.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/12.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/13.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/14.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/15.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/16.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/17.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/18.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/19.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/20.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/21.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/22.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/23.jpg" alt="">
        </div>
        <div class="amiibo">
            <img src="image/24.jpg" alt="">
        </div>
    </div>

</div>

<script type="text/javascript">

    const ws = new WebSocket("ws://192.168.3.44:8765");

    ws.onopen = function (evt) {
        console.log("Connection open ...");
        ws.send('connect')
    };

    ws.onmessage = function (evt) {
        console.log("Received Message: " + evt.data);
        if (evt.data === 'connected') {
            document.querySelector('.xbox').classList.add('on');
        } else if (evt.data === 'amiibo') {
            alert('amiibo load success!')
        } else if (evt.data === 'reset') {
            alert('amiibo reset!')
        }
    };

    ws.onclose = function (evt) {
        console.log("Connection closed.");
        document.querySelector('.xbox').classList.remove('on');
    };


    (function (l, r) {
        if (l.getElementById("livereloadscript")) return;
        r = l.createElement("script");
        r.async = 1;
        r.src =
            "//" +
            (window.location.host || "localhost").split(":")[0] +
            ":35730/livereload.js?snipver=1";
        r.id = "livereloadscript";
        l.getElementsByTagName("head")[0].appendChild(r);
    })(window.document);
    (function (global, factory) {
        typeof exports === "object" && typeof module !== "undefined"
            ? (module.exports = factory())
            : typeof define === "function" && define.amd
                ? define(factory)
                : ((global =
                    typeof globalThis !== "undefined" ? globalThis : global || self),
                    (global.GameController = factory()));
    })(this, function () {
            "use strict";

            function noop() {
            }

            function add_location(element, file, line, column, char) {
                element.__svelte_meta = {
                    loc: {file, line, column, char}
                };
            }

            function run(fn) {
                return fn();
            }

            function blank_object() {
                return Object.create(null);
            }

            function run_all(fns) {
                fns.forEach(run);
            }

            function is_function(thing) {
                return typeof thing === "function";
            }

            function safe_not_equal(a, b) {
                return a != a
                    ? b == b
                    : a !== b ||
                    (a && typeof a === "object") ||
                    typeof a === "function";
            }

            function is_empty(obj) {
                return Object.keys(obj).length === 0;
            }

            function append(target, node) {
                target.appendChild(node);
            }

            function insert(target, node, anchor) {
                target.insertBefore(node, anchor || null);
            }

            function detach(node) {
                node.parentNode.removeChild(node);
            }

            function element(name) {
                return document.createElement(name);
            }

            function text(data) {
                return document.createTextNode(data);
            }

            function space() {
                return text(" ");
            }

            function listen(node, event, handler, options) {
                node.addEventListener(event, handler, options);
                return () => node.removeEventListener(event, handler, options);
            }

            function attr(node, attribute, value) {
                if (value == null) node.removeAttribute(attribute);
                else if (node.getAttribute(attribute) !== value)
                    node.setAttribute(attribute, value);
            }

            function children(element) {
                return Array.from(element.childNodes);
            }

            function set_style(node, key, value, important) {
                node.style.setProperty(key, value, important ? "important" : "");
            }

            function toggle_class(element, name, toggle) {
                element.classList[toggle ? "add" : "remove"](name);
            }

            function custom_event(type, detail) {
                const e = document.createEvent("CustomEvent");
                e.initCustomEvent(type, false, false, detail);
                return e;
            }

            let current_component;

            function set_current_component(component) {
                current_component = component;
            }

            const dirty_components = [];
            const binding_callbacks = [];
            const render_callbacks = [];
            const flush_callbacks = [];
            const resolved_promise = Promise.resolve();
            let update_scheduled = false;

            function schedule_update() {
                if (!update_scheduled) {
                    update_scheduled = true;
                    resolved_promise.then(flush);
                }
            }

            function add_render_callback(fn) {
                render_callbacks.push(fn);
            }

            let flushing = false;
            const seen_callbacks = new Set();

            function flush() {
                if (flushing) return;
                flushing = true;
                do {
                    // first, call beforeUpdate functions
                    // and update components
                    for (let i = 0; i < dirty_components.length; i += 1) {
                        const component = dirty_components[i];
                        set_current_component(component);
                        update(component.$$);
                    }
                    dirty_components.length = 0;
                    while (binding_callbacks.length) binding_callbacks.pop()();
                    // then, once components are updated, call
                    // afterUpdate functions. This may cause
                    // subsequent updates...
                    for (let i = 0; i < render_callbacks.length; i += 1) {
                        const callback = render_callbacks[i];
                        if (!seen_callbacks.has(callback)) {
                            // ...so guard against infinite loops
                            seen_callbacks.add(callback);
                            callback();
                        }
                    }
                    render_callbacks.length = 0;
                } while (dirty_components.length);
                while (flush_callbacks.length) {
                    flush_callbacks.pop()();
                }
                update_scheduled = false;
                flushing = false;
                seen_callbacks.clear();
            }

            function update($$) {
                if ($$.fragment !== null) {
                    $$.update();
                    run_all($$.before_update);
                    const dirty = $$.dirty;
                    $$.dirty = [-1];
                    $$.fragment && $$.fragment.p($$.ctx, dirty);
                    $$.after_update.forEach(add_render_callback);
                }
            }

            const outroing = new Set();

            function transition_in(block, local) {
                if (block && block.i) {
                    outroing.delete(block);
                    block.i(local);
                }
            }

            function mount_component(component, target, anchor) {
                const {fragment, on_mount, on_destroy, after_update} = component.$$;
                fragment && fragment.m(target, anchor);
                // onMount happens before the initial afterUpdate
                add_render_callback(() => {
                    const new_on_destroy = on_mount.map(run).filter(is_function);
                    if (on_destroy) {
                        on_destroy.push(...new_on_destroy);
                    } else {
                        // Edge case - component was destroyed immediately,
                        // most likely as a result of a binding initialising
                        run_all(new_on_destroy);
                    }
                    component.$$.on_mount = [];
                });
                after_update.forEach(add_render_callback);
            }

            function destroy_component(component, detaching) {
                const $$ = component.$$;
                if ($$.fragment !== null) {
                    run_all($$.on_destroy);
                    $$.fragment && $$.fragment.d(detaching);
                    // TODO null out other refs, including component.$$ (but need to
                    // preserve final state?)
                    $$.on_destroy = $$.fragment = null;
                    $$.ctx = [];
                }
            }

            function make_dirty(component, i) {
                if (component.$$.dirty[0] === -1) {
                    dirty_components.push(component);
                    schedule_update();
                    component.$$.dirty.fill(0);
                }
                component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
            }

            let buttonPress = {
                a: 0,
                b: 0,
                x: 0,
                y: 0,
                lb: 0,
                rb: 0,
                lt: 0,
                rt: 0,
                map: 0,
                menu: 0,
                lstick: 0,
                rstick: 0,
                up: 0,
                down: 0,
                left: 0,
                right: 0,
                xbox: 0
            };
            let preAxis = {lx: 0, ly: 0, rx: 0, ry: 0};


            function compareAxes(one, two) {
                return Math.abs(one['lx'] - two['lx']) + Math.abs(one['ly'] - two['ly']) +
                    Math.abs(one['ry'] - two['ry']) + Math.abs(one['rx'] - two['rx']) > 0.1
            }


            function init(
                component,
                options,
                instance,
                create_fragment,
                not_equal,
                props,
                dirty = [-1]
            ) {
                const parent_component = current_component;
                set_current_component(component);
                const prop_values = options.props || {};
                const $$ = (component.$$ = {
                    fragment: null,
                    ctx: null,
                    // state
                    props,
                    update: noop,
                    not_equal,
                    bound: blank_object(),
                    // lifecycle
                    on_mount: [],
                    on_destroy: [],
                    before_update: [],
                    after_update: [],
                    context: new Map(
                        parent_component ? parent_component.$$.context : []
                    ),
                    // everything else
                    callbacks: blank_object(),
                    dirty,
                    skip_bound: false
                });
                let ready = false;
                $$.ctx = instance
                    ? instance(component, prop_values, (i, ret, ...rest) => {
                            const value = rest.length ? rest[0] : ret;
                            if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
                                if (i === 0) {
                                    for (let btn in value) {
                                        if (value[btn] === 1) {
                                            if (!buttonPress[btn]) {
                                                console.log(`${btn} pressed`)
                                                ws.send(`hold_${btn}`);
                                            }
                                            buttonPress[btn] = 1;
                                        } else if (value[btn] === 0) {
                                            if (buttonPress[btn]) {
                                                console.log(`${btn} release`)
                                                ws.send(`release_${btn}`);
                                            }
                                            buttonPress[btn] = 0;
                                        }
                                    }
                                } else if (i === 7) {
                                    // console.log(value)
                                    ws.send(`stick_${value.lx}/${value.ly}/${value.rx}/${value.ry}`)
                                }
                                if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
                                if (ready) make_dirty(component, i);
                            }
                            return ret;
                        }
                    )
                    :
                    [];
                $$.update();
                ready = true;
                run_all($$.before_update);
                // `false` as a special case of no DOM component
                $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
                if (options.target) {
                    if (options.hydrate) {
                        const nodes = children(options.target);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        $$.fragment && $$.fragment.l(nodes);
                        nodes.forEach(detach);
                    } else {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        $$.fragment && $$.fragment.c();
                    }
                    if (options.intro) transition_in(component.$$.fragment);
                    mount_component(component, options.target, options.anchor);
                    flush();
                }
                set_current_component(parent_component);
            }

            class SvelteComponent {
                $destroy() {
                    destroy_component(this, 1);
                    this.$destroy = noop;
                }

                $on(type, callback) {
                    const callbacks =
                        this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
                    callbacks.push(callback);
                    return () => {
                        const index = callbacks.indexOf(callback);
                        if (index !== -1) callbacks.splice(index, 1);
                    };
                }

                $set($$props) {
                    if (this.$$set && !is_empty($$props)) {
                        this.$$.skip_bound = true;
                        this.$$set($$props);
                        this.$$.skip_bound = false;
                    }
                }
            }

            function dispatch_dev(type, detail) {
                document.dispatchEvent(
                    custom_event(type, Object.assign({version: "3.24.1"}, detail))
                );
            }

            function append_dev(target, node) {
                dispatch_dev("SvelteDOMInsert", {target, node});
                append(target, node);
            }

            function insert_dev(target, node, anchor) {
                dispatch_dev("SvelteDOMInsert", {target, node, anchor});
                insert(target, node, anchor);
            }

            function detach_dev(node) {
                dispatch_dev("SvelteDOMRemove", {node});
                detach(node);
            }

            function listen_dev(
                node,
                event,
                handler,
                options,
                has_prevent_default,
                has_stop_propagation
            ) {
                const modifiers =
                    options === true
                        ? ["capture"]
                        : options
                            ? Array.from(Object.keys(options))
                            : [];
                if (has_prevent_default) modifiers.push("preventDefault");
                if (has_stop_propagation) modifiers.push("stopPropagation");
                dispatch_dev("SvelteDOMAddEventListener", {
                    node,
                    event,
                    handler,
                    modifiers
                });
                const dispose = listen(node, event, handler, options);
                return () => {
                    dispatch_dev("SvelteDOMRemoveEventListener", {
                        node,
                        event,
                        handler,
                        modifiers
                    });
                    dispose();
                };
            }

            function attr_dev(node, attribute, value) {
                attr(node, attribute, value);
                if (value == null)
                    dispatch_dev("SvelteDOMRemoveAttribute", {node, attribute});
                else dispatch_dev("SvelteDOMSetAttribute", {node, attribute, value});
            }

            function validate_slots(name, slot, keys) {
                for (const slot_key of Object.keys(slot)) {
                    if (!~keys.indexOf(slot_key)) {
                        console.warn(
                            `<${name}> received an unexpected slot "${slot_key}".`
                        );
                    }
                }
            }

            class SvelteComponentDev extends SvelteComponent {
                constructor(options) {
                    if (!options || (!options.target && !options.$$inline)) {
                        throw new Error(`'target' is a required option`);
                    }
                    super();
                }

                $destroy() {
                    super.$destroy();
                    this.$destroy = () => {
                        console.warn(`Component was already destroyed`); // eslint-disable-line no-console
                    };
                }

                $capture_state() {
                }

                $inject_state() {
                }
            }

            /* src/Controller.svelte generated by Svelte v3.24.1 */

            const file = "src/Controller.svelte";

            function create_fragment(ctx) {
                let section;
                let div0;
                let t0;
                let div2;
                let div1;
                let t1;
                let div4;
                let div3;
                let t2;
                let button0;
                let t3;
                let button1;
                let t4;
                let button2;
                let t5;
                let button3;
                let t6;
                let button4;
                let t7;
                let button5;
                let t8;
                let button6;
                let t9;
                let button7;
                let t10;
                let button8;
                let t11;
                let button9;
                let t12;
                let button10;
                let t13;
                let button11;
                let t14;
                let button12;
                let t15;
                let button13;
                let button13_style_value;
                let t16;
                let button14;
                let button14_style_value;
                let mounted;
                let dispose;

                const block = {
                    c: function create() {
                        section = element("section");
                        div0 = element("div");
                        t0 = space();
                        div2 = element("div");
                        div1 = element("div");
                        t1 = space();
                        div4 = element("div");
                        div3 = element("div");
                        t2 = space();
                        button0 = element("button");
                        t3 = space();
                        button1 = element("button");
                        t4 = space();
                        button2 = element("button");
                        t5 = space();
                        button3 = element("button");
                        t6 = space();
                        button4 = element("button");
                        t7 = space();
                        button5 = element("button");
                        t8 = space();
                        button6 = element("button");
                        t9 = space();
                        button7 = element("button");
                        t10 = space();
                        button8 = element("button");
                        t11 = space();
                        button9 = element("button");
                        t12 = space();
                        button10 = element("button");
                        t13 = space();
                        button11 = element("button");
                        t14 = space();
                        button12 = element("button");
                        t15 = space();
                        button13 = element("button");
                        t16 = space();
                        button14 = element("button");
                        attr_dev(div0, "class", "pad svelte-1xis06h");
                        add_location(div0, file, 94, 1, 1831);
                        attr_dev(div1, "class", "stick svelte-1xis06h");
                        set_style(div1, "transform", /*stickl*/ ctx[1]());
                        toggle_class(div1, "click", /*buttonMap*/ ctx[0].lstick);
                        add_location(div1, file, 96, 2, 1882);
                        attr_dev(div2, "class", "well left svelte-1xis06h");
                        add_location(div2, file, 95, 1, 1856);
                        attr_dev(div3, "class", "stick svelte-1xis06h");
                        set_style(div3, "transform", /*stickr*/ ctx[2]());
                        toggle_class(div3, "click", /*buttonMap*/ ctx[0].rstick);
                        add_location(div3, file, 99, 2, 2006);
                        attr_dev(div4, "class", "well right svelte-1xis06h");
                        add_location(div4, file, 98, 1, 1979);
                        attr_dev(button0, "class", "button a svelte-1xis06h");
                        toggle_class(button0, "on", /*buttonMap*/ ctx[0].a);
                        add_location(button0, file, 101, 1, 2103);
                        attr_dev(button1, "class", "button b svelte-1xis06h");
                        toggle_class(button1, "on", /*buttonMap*/ ctx[0].b);
                        add_location(button1, file, 102, 1, 2162);
                        attr_dev(button2, "class", "button x svelte-1xis06h");
                        toggle_class(button2, "on", /*buttonMap*/ ctx[0].x);
                        add_location(button2, file, 103, 1, 2221);
                        attr_dev(button3, "class", "button y svelte-1xis06h");
                        toggle_class(button3, "on", /*buttonMap*/ ctx[0].y);
                        add_location(button3, file, 104, 1, 2280);
                        attr_dev(button4, "class", "button map svelte-1xis06h");
                        toggle_class(button4, "on", /*buttonMap*/ ctx[0].map);
                        add_location(button4, file, 105, 1, 2339);
                        attr_dev(button5, "class", "button menu svelte-1xis06h");
                        toggle_class(button5, "on", /*buttonMap*/ ctx[0].menu);
                        add_location(button5, file, 106, 1, 2402);
                        attr_dev(button6, "class", "button xbox svelte-1xis06h");
                        // toggle_class(button6, "on", /*buttonMap*/ ctx[0].xbox);
                        add_location(button6, file, 107, 1, 2467);
                        attr_dev(button7, "class", "dpad du svelte-1xis06h");
                        toggle_class(button7, "on", /*buttonMap*/ ctx[0].up);
                        add_location(button7, file, 108, 1, 2532);
                        attr_dev(button8, "class", "dpad dr svelte-1xis06h");
                        toggle_class(button8, "on", /*buttonMap*/ ctx[0].right);
                        add_location(button8, file, 109, 1, 2591);
                        attr_dev(button9, "class", "dpad dd svelte-1xis06h");
                        toggle_class(button9, "on", /*buttonMap*/ ctx[0].down);
                        add_location(button9, file, 110, 1, 2650);
                        attr_dev(button10, "class", "dpad dl svelte-1xis06h");
                        toggle_class(button10, "on", /*buttonMap*/ ctx[0].left);
                        add_location(button10, file, 111, 1, 2709);
                        attr_dev(button11, "class", "bumper left svelte-1xis06h");
                        toggle_class(button11, "on", /*buttonMap*/ ctx[0].lb);
                        add_location(button11, file, 112, 1, 2768);
                        attr_dev(button12, "class", "bumper right svelte-1xis06h");
                        toggle_class(button12, "on", /*buttonMap*/ ctx[0].rb);
                        add_location(button12, file, 113, 1, 2831);
                        attr_dev(button13, "class", "trigger left svelte-1xis06h");
                        attr_dev(
                            button13,
                            "style",
                            (button13_style_value = /*trigger*/ ctx[3]("lt"))
                        );
                        add_location(button13, file, 114, 1, 2895);
                        attr_dev(button14, "class", "trigger right svelte-1xis06h");
                        attr_dev(
                            button14,
                            "style",
                            (button14_style_value = /*trigger*/ ctx[3]("rt"))
                        );
                        add_location(button14, file, 115, 1, 2959);
                        attr_dev(section, "class", "controller svelte-1xis06h");
                        add_location(section, file, 93, 0, 1801);
                    },
                    l: function claim(nodes) {
                        throw new Error(
                            "options.hydrate only works if the component was compiled with the `hydratable: true` option"
                        );
                    },
                    m: function mount(target, anchor) {
                        insert_dev(target, section, anchor);
                        append_dev(section, div0);
                        append_dev(section, t0);
                        append_dev(section, div2);
                        append_dev(div2, div1);
                        append_dev(section, t1);
                        append_dev(section, div4);
                        append_dev(div4, div3);
                        append_dev(section, t2);
                        append_dev(section, button0);
                        append_dev(section, t3);
                        append_dev(section, button1);
                        append_dev(section, t4);
                        append_dev(section, button2);
                        append_dev(section, t5);
                        append_dev(section, button3);
                        append_dev(section, t6);
                        append_dev(section, button4);
                        append_dev(section, t7);
                        append_dev(section, button5);
                        append_dev(section, t8);
                        append_dev(section, button6);
                        append_dev(section, t9);
                        append_dev(section, button7);
                        append_dev(section, t10);
                        append_dev(section, button8);
                        append_dev(section, t11);
                        append_dev(section, button9);
                        append_dev(section, t12);
                        append_dev(section, button10);
                        append_dev(section, t13);
                        append_dev(section, button11);
                        append_dev(section, t14);
                        append_dev(section, button12);
                        append_dev(section, t15);
                        append_dev(section, button13);
                        append_dev(section, t16);
                        append_dev(section, button14);

                        if (!mounted) {
                            dispose = [
                                listen_dev(
                                    window,
                                    "gamepadconnected",
                                    /*plugIn*/ ctx[4],
                                    false,
                                    false,
                                    false
                                ),
                                listen_dev(
                                    window,
                                    "gamepaddisconnected",
                                    /*unPlug*/ ctx[5],
                                    false,
                                    false,
                                    false
                                )
                            ];

                            mounted = true;
                        }
                    },
                    p: function update(ctx, [dirty]) {
                        if (dirty & /*stickl*/ 2) {
                            set_style(div1, "transform", /*stickl*/ ctx[1]());
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(div1, "click", /*buttonMap*/ ctx[0].lstick);
                        }

                        if (dirty & /*stickr*/ 4) {
                            set_style(div3, "transform", /*stickr*/ ctx[2]());
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(div3, "click", /*buttonMap*/ ctx[0].rstick);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button0, "on", /*buttonMap*/ ctx[0].a);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button1, "on", /*buttonMap*/ ctx[0].b);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button2, "on", /*buttonMap*/ ctx[0].x);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button3, "on", /*buttonMap*/ ctx[0].y);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button4, "on", /*buttonMap*/ ctx[0].map);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button5, "on", /*buttonMap*/ ctx[0].menu);
                        }

                        // if (dirty & /*buttonMap*/ 1) {
                        //     toggle_class(button6, "on", /*buttonMap*/ ctx[0].xbox);
                        // }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button7, "on", /*buttonMap*/ ctx[0].up);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button8, "on", /*buttonMap*/ ctx[0].right);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button9, "on", /*buttonMap*/ ctx[0].down);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button10, "on", /*buttonMap*/ ctx[0].left);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button11, "on", /*buttonMap*/ ctx[0].lb);
                        }

                        if (dirty & /*buttonMap*/ 1) {
                            toggle_class(button12, "on", /*buttonMap*/ ctx[0].rb);
                        }

                        if (
                            dirty & /*trigger*/ 8 &&
                            button13_style_value !==
                            (button13_style_value = /*trigger*/ ctx[3]("lt"))
                        ) {
                            attr_dev(button13, "style", button13_style_value);
                        }

                        if (
                            dirty & /*trigger*/ 8 &&
                            button14_style_value !==
                            (button14_style_value = /*trigger*/ ctx[3]("rt"))
                        ) {
                            attr_dev(button14, "style", button14_style_value);
                        }
                    },
                    i: noop,
                    o: noop,
                    d: function destroy(detaching) {
                        if (detaching) detach_dev(section);
                        mounted = false;
                        run_all(dispose);
                    }
                };

                dispatch_dev("SvelteRegisterBlock", {
                    block,
                    id: create_fragment.name,
                    type: "component",
                    source: "",
                    ctx
                });

                return block;
            }

            function instance($$self, $$props, $$invalidate) {
                let poll;

                let buttonMap = {
                    a: 0,
                    b: 0,
                    x: 0,
                    y: 0,
                    lb: 0,
                    rb: 0,
                    lt: 0,
                    rt: 0,
                    map: 0,
                    menu: 0,
                    lstick: 0,
                    rstick: 0,
                    up: 0,
                    down: 0,
                    left: 0,
                    right: 0,
                    xbox: 0
                };

                let axisMap = {lx: 0, ly: 0, rx: 0, ry: 0};
                let preAxisMap = {lx: 0, ly: 0, rx: 0, ry: 0};
                const plugIn = () => {
                    startController();
                };

                const unPlug = () => {
                    cancelAnimationFrame(poll);
                };

                const startController = () => {
                    const gamepads = navigator.getGamepads();

                    if (!gamepads) {
                        return;
                    }

                    const pad = gamepads[0];

                    const buttons = [
                        "a",
                        "b",
                        "x",
                        "y",
                        "lb",
                        "rb",
                        "lt",
                        "rt",
                        "map",
                        "menu",
                        "lstick",
                        "rstick",
                        "up",
                        "down",
                        "left",
                        "right",
                        "xbox"
                    ];

                    const axes = ["lx", "ly", "rx", "ry"];

                    pad.buttons.forEach((button, i) => {
                        $$invalidate(
                            0,
                            (buttonMap[buttons[i]] = button.pressed ? button.value : 0),
                            buttonMap
                        );
                    });

                    pad.axes.forEach((axis, i) => {
                        axisMap[axes[i]] = axis > 0.01 || axis < -0.01 ? parseFloat(axis.toFixed(3)) : 0
                        if (compareAxes(preAxisMap, axisMap)) {
                            $$invalidate(
                                7,
                                (axisMap[axes[i]] =
                                    axis > 0.01 || axis < -0.01
                                        ? parseFloat(axis.toFixed(3))
                                        : 0),
                                axisMap
                            );
                            preAxis = axisMap;
                        }

                    });

                    poll = requestAnimationFrame(startController);
                };

                const writable_props = [];

                Object.keys($$props).forEach((key) => {
                    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
                        console.warn(
                            `<Controller> was created with unknown prop '${key}'`
                        );
                });

                let {$$slots = {}, $$scope} = $$props;
                validate_slots("Controller", $$slots, []);

                $$self.$capture_state = () => ({
                    poll,
                    buttonMap,
                    axisMap,
                    plugIn,
                    unPlug,
                    startController,
                    stickl,
                    stickr,
                    trigger
                });


                $$self.$inject_state = ($$props) => {
                    if ("poll" in $$props) poll = $$props.poll;
                    if ("buttonMap" in $$props) $$invalidate(0, (buttonMap = $$props.buttonMap));
                    if ("axisMap" in $$props) $$invalidate(7, (axisMap = $$props.axisMap));
                    if ("stickl" in $$props) $$invalidate(1, (stickl = $$props.stickl));
                    if ("stickr" in $$props) $$invalidate(2, (stickr = $$props.stickr));
                    if ("trigger" in $$props)
                        $$invalidate(3, (trigger = $$props.trigger));
                };

                let stickl;
                let stickr;
                let trigger;

                if ($$props && "$$inject" in $$props) {
                    $$self.$inject_state($$props.$$inject);
                }

                $$self.$$.update = () => {
                    if ($$self.$$.dirty & /*axisMap, buttonMap*/ 129) {
                        $$invalidate(
                            1,
                            (stickl = () => {
                                let x = axisMap.lx * 25;
                                let y = axisMap.ly * 25;
                                let rx = axisMap.lx * 10;
                                let ry = axisMap.ly * 10;
                                let z = 1 - buttonMap.lstick * 0.05;
                                return `translateX(${x}%) translateY(${y}%) rotateY(${rx}deg) rotateX(${ry}deg) scale(${z})`;
                            })
                        );
                    }

                    if ($$self.$$.dirty & /*axisMap, buttonMap*/ 129) {
                        $$invalidate(
                            2,
                            (stickr = () => {
                                let x = axisMap.rx * 25;
                                let y = axisMap.ry * 25;
                                let rx = axisMap.rx * 10;
                                let ry = axisMap.ry * 10;
                                let z = 1 - buttonMap.rstick * 0.05;
                                return `translateX(${x}%) translateY(${y}%) rotateY(${rx}deg) rotateX(${ry}deg) scale(${z})`;
                            })
                        );
                    }

                    if ($$self.$$.dirty & /*buttonMap*/ 1) {
                        $$invalidate(
                            3,
                            (trigger = (side) => {
                                let s = buttonMap[side];
                                let sx = side === "rt" ? -s : s;

                                return `
			transform: scaleX(${sx}) scaleY(${s}) rotate(-69deg);
			opacity: ${0.3 + s};
		`;
                            })
                        );
                    }
                };

                return [buttonMap, stickl, stickr, trigger, plugIn, unPlug];
            }

            class Controller extends SvelteComponentDev {
                constructor(options) {
                    super(options);
                    init(this, options, instance, create_fragment, safe_not_equal, {});

                    dispatch_dev("SvelteRegisterComponent", {
                        component: this,
                        tagName: "Controller",
                        options,
                        id: create_fragment.name
                    });
                }
            }

            return Controller;
        }
    )
    ;
    //# sourceMappingURL=bundle.js.map

    new GameController({
        target: document.getElementById("pad")
    });


    document.querySelector('#right').style.height = document.querySelector('#left').offsetHeight + 'px'
    document.querySelector('#list').style.height = document.querySelector('.pad').offsetHeight + 'px'

    let amiibo_click = false
    document.querySelectorAll('.amiibo').forEach(item => {
        item.onclick = () => {
            if (!amiibo_click) {
                const pattern = /(\d)+/
                const amiibo_id = pattern.exec(item.querySelector('img').getAttribute('src'))[0]
                ws.send(`amiibo_${amiibo_id}`)
                amiibo_click = true
            } else {
                ws.send(`amiibo_reset`)
                amiibo_click = false
            }

        }
    })
</script>
</body>
</html>
